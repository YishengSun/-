
网络的核心部分：大量的网络和路由器

进程：运行着的程序

网络核心部分中起特殊作用的是路由器，一种特殊的计算机，不做主机，任务是转发收到的分组，进行分组交换

分组：要发送的整块数据称为报文，发送前现将它分割成等长的数据段，再加入一些控制信息作为首部后，成为了分组。分组又称为包，首部又称为包头。首部的意义在于包含了目的地址和源地址等重要的控制信息，每个分组才能在互联网中独立的选择传输路径

存储转发：路由器收到分组，先暂时存储，检查首部，查找转发表，按照首部中的目的地址，找到合适的接口转发到下一个路由器

计算机网络体系结构：应用层->运输层->网络层->数据链路层->物理层

应用层：通过应用层之间的交互来完成特定网络应用。应用层协议定义的是应用进程间通信和交互的规则。不同的网络应用有不同的应用层协议，如域名系统DNS，HTTP协议

运输层：负责为两台主机进程之间的通信提供通用的数据传输服务。通用的，是指不针对某个特定的网络应用。传输层主要有两种协议：TCP 和 UDP

TCP：提供面向连接的、可靠的数据传输服务

UDP：提供无连接的、尽最大努力的数据传输服务（不保证数据传输的可靠性）

网络层：负责为分组交换的不同主机提供通信服务，使用IP协议














应用层

域名系统DNS：把用户输入的主机名字（域名）转化为ip地址

域名：mail.cctv.com 三级->二级->顶级，每个以点号隔开的被称为一个标号

url：表示从互联网上得到的资源的位置和访问这些资源的方法

HTTP协议：定义了浏览器（用户）怎样向万维网服务器请求万维网文档，以及服务起怎样把文档传送给浏览器。无连接，无状态的

过程：每个万维网的网点都有一个服务器进程在不断监听TCP的80端口。一旦有浏览器发出请求连接，就会通过三次握手建立TCP连接，万维网客户把HTTP请求报文作为第三次握手的报文发送给服务器，服务器收到后，把请求的文档作为响应报文返回给客户。所以请求得到一个文档所需要的时间是2倍来回时间RTT。

HTTP/1.0：每次请求得到都要2*RTT，每次建立TCP连接都要分配缓存和变量，非持续连接。
HTTP/1.1：持续连接

一个HTTP请求报文例子：
GET /dir/index.html HTTP/1.1
Host: www.xyz.edu.cn
Connection: close
User-Agent: Mozilla/5.0
Accept-Language:cn
每个http请求报文发出后，都会收到一个包含状态行的响应报文
状态行：HTTP版本+状态码+少许解释

5大状态码：
1xx 表示通知信息，如请求收到了或正在处理中
2xx 表示成功
3xx 表示重定向，如资源被转移了
4xx 客户端错误，如请求中有错误的语法或无法完成请求
5xx 服务器错误，如服务器失效

Cookie：由于http是无状态的，所以需要cookie跟踪用户。过程：用户A访问某网站，该网站就为该用户生成一个唯一的识别码，并以此在后端数据库产生一个项目，接着在给A的响应报文里添加一个set-cookie的首部行，当浏览器收到这个响应后，在自己管理的cookie文件中添加一行，包括这个服务器的主机名和A的识别码，再之后向服务器的HTTP请求报文中，浏览器会取出这个识别码并放到http请求报文的首部行中。
运输层
运输层向他上面的应用层提供通信服务。网络层的IP协议虽然能把分组送到目的主机，但是这歌分组还没有到主机的应用进程中。从应用层的角度来看，通信的真正端点是主机中的进程，端到端的通信是应用进程之间的通信。

TCP：传输控制协议。提供面向连接的服务，在传送数据之前必须要先建立连接，数据传送后要释放连接。TCP连接的两个端点是套接字socket（即IP地址：端口号）

停止等待协议：A向B发送分组，直到A接收到B确认收到分组后，才发送下一个分组。如裹在一段时间内都没有收到B的确认，那么就会超时重传这个分组。

TCP报文的首部几个控制位：
1.	确认ACK：在连接建立后所有的报文段都要把ACK设置为1
2.	同步SYN：SYN为1而ACK为0，表明这是个请求连接报文段，对方若同意连接，则响应报文SYN为1，ACK为1
3.	终止FIN：当FIN=1，表明此报文段的发送方数据已发送完毕，并要求释放运输连接

三次握手：B传输控制块不断监听80端口（如果是http），
1.	A首先向B发送请求连接报文段，SYN=1，ACK=0，初始序号seq=x，不能携带数据，但要消耗一个序号，此时TCP客户端A进入SYN-SENT状态
2.	B接收到请求连接的报文，向A发送确认，SYN=1，ACK=1，ack=x+1（下一个希望获得的数据的起始序号），seq=y，也不能携带数据，但要消耗一个服务器端的序号，此时TCP服务器端进入SYN-RCVD状态
3.	客户端A收到B的确认，返回确认确认的报文段，ACK=1，seq=x+1，ack=y+1，可以携带数据（http请求的报文就是在这时发送），此时A进入ESTABLISHED状态
4.	B收到后，也进入ESTABLISHED状态


四次挥手
1.	A主动关闭TCP连接，发送请求释放连接的报文段，FIN=1，seq=u，此时A进入FIN-Wait-1
2.	B收到释放连接的报文段，发出确认，seq=v，ack=u+1，此时A到B方向关闭，TCP处于半关闭状态，B进入CLOSE-WAIT状态，但是B还可以继续发送剩余数据
3.	A收到B的确认，进入FIN-wait-2。当B没有数据再需要发送的时候，B发送连接释放报文段，FIN=1，ACK=1，seq=w，ack=u+1，此时B进入LAST-ACK
4.	A收到并回复确认，ACK=1，seq=u+1，ack=w+1，然后A进入TIME-WAIT（目的是确认B收到自己的确认），之后进入CLOSED
5.	B在接收后进入CLOSED




http: 超文本传输协议，是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。

https: 是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。

简单来说https协议是由http和ssl协议构建的可进行加密传输和身份认证的网络协议，比http协议的安全性更高。https://juejin.im/entry/58d7635e5c497d0057fae036


WebSocket是HTML5中的协议，支持持久连续，http协议不支持持久性连接。
HTTP的生命周期通过Request来界定，也就是Request一个Response，那么在Http1.0协议中，这次Http请求就结束了。在Http1.1中进行了改进，是的有一个connection：Keep-alive，也就是说，在一个Http连接中，可以发送多个Request，接收多个Response。但是必须记住，在Http中一个Request只能对应有一个Response，而且这个Response是被动的，不能主动发起。

fetch发送2次请求的原因
fetch发送post请求的时候，总是发送2次，第一次状态码是204，第二次才成功？

原因很简单，因为你用fetch的post请求的时候，导致fetch 第一次发送了一个Options请求，询问服务器是否支持修改的请求头，如果服务器支持，则在第二次中发送真正的请求。

补充400和401、403状态码
(1)400状态码：请求无效
产生原因：

前端提交数据的字段名称和字段类型与后台的实体没有保持一致
前端提交到后台的数据应该是json字符串类型，但是前端没有将对象JSON.stringify转化成字符串。
解决方法：

对照字段的名称，保持一致性
将obj对象通过JSON.stringify实现序列化
(2)401状态码：当前请求需要用户验证
(3)403状态码：服务器已经得到请求，但是拒绝执行




Cookie、sessionStorage、localStorage
Cookie之前说了，sessionStorage、localStorage都不会	



Js垃圾回收机制
1.	引用计数垃圾收集
垃圾回收算法主要依赖于引用的概念。在内存管理的环境中，一个对象如果有访问另一个对象的权限（隐式或者显式），叫做一个对象引用另一个对象。

var o = { 
  a: {
    b:2
  }
}; 
// 两个对象被创建，一个作为另一个的属性被引用，另一个被分配给变量o
// 很显然，没有一个可以被垃圾收集


var o2 = o; // o2变量是第二个对“这个对象”的引用

o = 1;      // 现在，“这个对象”只有一个o2变量的引用了，“这个对象”的原始引用o已经没有

var oa = o2.a; // 引用“这个对象”的a属性
               // 现在，“这个对象”有两个引用了，一个是o2，一个是oa

o2 = "yo"; // 虽然最初的对象现在已经是零引用了，可以被垃圾回收了
           // 但是它的属性a的对象还在被oa引用，所以还不能回收

oa = null; // a属性的那个对象现在也是零引用了
           // 它可以被垃圾回收了
2.	标记清除算法

这个算法假定设置一个叫做根（root）的对象（在Javascript里，根是全局对象）。垃圾回收器将定期从根开始，找所有从根开始引用的对象，然后找这些对象引用的对象……从根开始，垃圾回收器将找到所有可以获得的对象和收集所有不能获得的对象。


